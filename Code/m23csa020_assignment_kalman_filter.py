# -*- coding: utf-8 -*-
"""M23CSA020_Assignment_Kalman_Filter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jt-eVXG0V8bjUSxtORSXVU9OxhywlpDA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Kalman filter implementation
def kalman_filter(mu_prev, Sigma_prev, u_t, z_t, A_t, B_t, R_t, C_t, Q_t):
    # Prediction Step
    mu_hat = A_t @ mu_prev + B_t @ u_t
    Sigma_hat = A_t @ Sigma_prev @ A_t.T + R_t

    # Kalman Gain
    K_t = Sigma_hat @ C_t.T @ np.linalg.inv(C_t @ Sigma_hat @ C_t.T + Q_t)

    # Update Step
    mu_t = mu_hat + K_t @ (z_t - C_t @ mu_hat)
    Sigma_t = (np.eye(Sigma_hat.shape[0]) - K_t @ C_t) @ Sigma_hat

    return mu_t, Sigma_t

# Experimental function to test different configurations
def run_experiment(noise_levels, accelerations, measurement_intervals, num_steps=50, dt=0.001):
    results = []  # To store results for each experiment

    for process_noise, measurement_noise in noise_levels:
        for accel_type, accel_func in accelerations:
            for T_measure in measurement_intervals:
                measurement_interval = T_measure // (dt * 1000)  # Convert to number of steps

                # System matrices (state transition and control matrices)
                A_t = np.array([[1, 0, 0, dt, 0, 0],
                                [0, 1, 0, 0, dt, 0],
                                [0, 0, 1, 0, 0, dt],
                                [0, 0, 0, 1, 0, 0],
                                [0, 0, 0, 0, 1, 0],
                                [0, 0, 0, 0, 0, 1]])
                B_t = np.array([[0.5 * dt**2, 0, 0],
                                [0, 0.5 * dt**2, 0],
                                [0, 0, 0.5 * dt**2],
                                [dt, 0, 0],
                                [0, dt, 0],
                                [0, 0, dt]])
                C_t = np.eye(6)[:3, :]  # Measurement matrix (only position is measured)

                # Covariance matrices for process and measurement noise
                R_t = process_noise * np.eye(6)
                Q_t = measurement_noise * np.eye(3)

                # Initialize state and covariance
                mu_prev = np.array([0, 0, 0, 0, 0, 0])
                Sigma_prev = np.eye(6)

                # Lists to store results for this configuration
                true_positions = []
                estimated_positions = []
                errors = []

                for t in range(num_steps):
                    # Compute the acceleration for the current time step
                    a_t = accel_func(t)

                    # True state propagation (using the known system dynamics)
                    if t == 0:
                        true_state = mu_prev
                    else:
                        true_velocity = true_state[:3] + a_t * dt
                        true_position = true_state[3:] + true_velocity * dt
                        true_state = np.concatenate((true_velocity, true_position))
                    true_positions.append(true_state[3:])

                    # RADAR measurement (noisy observation every T steps)
                    if t % measurement_interval == 0:
                        z_t = true_state[3:] + np.random.normal(0, measurement_noise, 3)
                    else:
                        z_t = None  # No measurement available

                    # Apply Kalman Filter if measurement is available
                    if z_t is not None:
                        mu_prev, Sigma_prev = kalman_filter(mu_prev, Sigma_prev, a_t, z_t, A_t, B_t, R_t, C_t, Q_t)

                    estimated_positions.append(mu_prev[3:])

                    # Calculate error (Euclidean distance)
                    error = np.linalg.norm(true_state[3:] - mu_prev[3:])
                    errors.append(error)

                # Average error for this configuration
                avg_error = np.mean(errors)

                # Store results
                results.append({
                    "Process Noise": process_noise,
                    "Measurement Noise": measurement_noise,
                    "Acceleration Type": accel_type,
                    "Measurement Interval": T_measure,
                    "Average Error": avg_error
                })

                # Plotting for each configuration
                true_positions = np.array(true_positions)
                estimated_positions = np.array(estimated_positions)

                plt.figure(figsize=(10, 5))
                plt.plot(true_positions[:, 0], true_positions[:, 1], label="True Position", marker='o', linestyle="--")
                plt.plot(estimated_positions[:, 0], estimated_positions[:, 1], label="Estimated Position", marker='x')
                plt.xlabel("X Position")
                plt.ylabel("Y Position")
                plt.title(f"True vs Estimated Position for {accel_type} acceleration, Process Noise={process_noise}, Measurement Noise={measurement_noise}")
                plt.legend()
                plt.grid(True)
                plt.show()

    # Convert results to a DataFrame and save as CSV
    df_results = pd.DataFrame(results)
    df_results.to_csv('kalman_filter_experiment_results.csv', index=False)

    # Display DataFrame
    return df_results

# Define experimental parameters
noise_levels = [(0.01, 0.1), (0.1, 0.2)]  # Different combinations of process and measurement noise
accelerations = [
    ("constant", lambda t: np.array([0.1, 0.1, 0.1])),          # Constant acceleration
    ("time-dependent", lambda t: np.array([0.1 * (1 + 0.01 * t)] * 3))  # Time-dependent acceleration
]
measurement_intervals = [7, 15]  # Different measurement intervals in milliseconds

# Run experiments
experiment_results = run_experiment(noise_levels, accelerations, measurement_intervals)
experiment_results  # Display first few rows of the results

